#summary Asynchronous Image Loading with AndroidQuery

<wiki:gadget url="http://android-query.googlecode.com/svn/trunk/gadget/twitter.xml?v=19" height="115" width="450" border="0" /> 

== Code ==

Asynchronous image loading is easy with AQuery.

===Simple===
{{{
//load an image to an ImageView from network, cache image to file and memory

aq.id(R.id.image1).image("http://www.vikispot.com/z/images/vikispot/android-w.png");
}}}

===Cache Control===
{{{

//load an image from network, but only cache with file

//this image is huge, avoid memory caching
boolean memCache = false;
boolean fileCache = true;

aq.id(R.id.image1).image("http://www.vikispot.com/z/images/vikispot/android-w.png", memCache, fileCache);
}}}

===Down Sampling (handling huge images)===
{{{

//we are loading a huge image from the network, but we only need the image to be bigger than 200 pixels wide
//passing in the target width of 200 will down sample the image to conserve memory
//aquery will only down sample with power of 2 (2,4,8...) for good image quality and efficiency
//the resulting image width will be between 200 and 399 pixels

String imageUrl = "http://farm6.static.flickr.com/5035/5802797131_a729dac808_b.jpg";		
aq.id(R.id.image1).image(imageUrl, true, true, 200, 0);
}}}

Related Blog: [http://blog.androidquery.com/2011/05/down-sample-images-to-avoid-out-of.html Downsampling]

===Fallback Image===

{{{

//if we are not able to load the image, use a default image (R.drawable.default_image)

String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";
aq.id(R.id.image1).image(imageUrl, true, true, 0, R.drawable.default_image);

//make image view "invisible" if image failed to load
imageUrl = "http://a.b.com/invalid.jpg";		
aq.id(R.id.image1).image(imageUrl, true, true, 0, AQuery.INVISIBLE);


//make image view "gone" if image failed to load
aq.id(R.id.image1).image(imageUrl, true, true, 0, AQuery.GONE);


}}}

===Preloading===
{{{

//get the bitmap for a previously fetched thumbnail
String thumbnail = "http://farm6.static.flickr.com/5035/5802797131_a729dac808_s.jpg";	
Bitmap preset = aq.getCachedImage(thumbnail);

//set the image view with a thumbnail, and fetch the high resolution image asynchronously
String imageUrl = "http://farm6.static.flickr.com/5035/5802797131_a729dac808_b.jpg";		
aq.id(R.id.image).image(imageUrl, false, false, 0, 0, preset, AQuery.FADE_IN);

}}}

===Animation===
{{{

//display the image with a predefined fade in animation
String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";		
aq.id(R.id.image).image(imageUrl, true, true, 0, null, 0, AQuery.FADE_IN);

}}}

===Aspect Ratio===

=====Preserve Image Aspect Ratio=====

{{{
String imageUrl = "http://farm3.static.flickr.com/2199/2218403922_062bc3bcf2.jpg";	
aq.id(R.id.image).image(imageUrl, true, true, 0, 0, null, AQuery.FADE_IN, AQuery.RATIO_PRESERVE);

}}}

=====Fixed Predefined Aspect Ratio=====

{{{

String imageUrl = "http://farm3.static.flickr.com/2199/2218403922_062bc3bcf2.jpg";	

aq.id(R.id.image1).image(imageUrl, true, true, 0, 0, null, 0, AQuery.RATIO_PRESERVE);	

//1:1, a square	
aq.id(R.id.image2).image(imageUrl, true, true, 0, 0, null, 0, 1.0f / 1.0f);		
aq.id(R.id.image3).image(imageUrl, true, true, 0, 0, null, 0, 1.5f / 1.0f);	
	
//16:9, a video thumbnail
aq.id(R.id.image4).image(imageUrl, true, true, 0, 0, null, 0, 9.0f / 16.0f);	
aq.id(R.id.image5).image(imageUrl, true, true, 0, 0, null, 0, 3.0f / 4.0f);
}}}

===Custom Callback===

{{{
String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";

final int tint = 0x77AA0000;

aq.id(R.id.image1).image(imageUrl, true, true, 0, 0, new BitmapAjaxCallback(){

	@Override
	public void callback(String url, ImageView iv, Bitmap bm, AjaxStatus status){
				
		iv.setImageBitmap(bm);
		
		//do something to the bitmap
		iv.setColorFilter(tint, PorterDuff.Mode.SRC_ATOP);
		
	}
	
});

}}}

=== File (Async) ===

Load image from a file asynchronously. Down sampling is recommended when loading huge images from camera or gallery to avoid out of memory errors.

=====Simple=====
{{{

File file = new File(path);        

//load image from file, down sample to target width of 300 pixels  
aq.id(R.id.avatar).image(file, 300);

}}}

=====Callback=====

{{{

File file = new File(path);

//load image from file with callback
aq.id(R.id.avatar).image(file, false, 300, new BitmapAjaxCallback(){

    @Override
    public void callback(String url, ImageView iv, Bitmap bm, AjaxStatus status){
    	
    	iv.setImageBitmap(bm);
        
    	//do something with the bm
        
    }
    
});

}}}
=== Duplicated URL ===
{{{

//AQuery detects duplicated image urls request and only fetches 1 image and apply them to all associated image views

String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";
aq.id(R.id.image1).image(imageUrl);

//no network fetch for 2nd request, image will be shown when first request is completed
aq.id(R.id.image2).image(imageUrl);

}}}

=== Access Cached Images ===

{{{
//returns the cached file by url, returns null if url is not cached
File file = aq.getCachedFile(url);
}}}

=== List View Example ===

When working with AQuery, make sure the views you want to operate can be "findBy" the view or activity you created with the AQuery object. In the case for rendering list items, create an AQuery object with the item container view. 

Here's an example.

{{{
ArrayAdapter<JSONObject> aa = new ArrayAdapter<JSONObject>(this, R.layout.content_item_s, items){
	
	@Override
	public View getView(int position, View view, ViewGroup parent) {
		
		if(view == null){
			view = ((LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE)).inflate(R.layout.content_item_s, null);
		}
		
		JSONObject jo = getItem(position);
		
		AQuery aq = new AQuery(view);
		aq.id(R.id.name).text(jo.optString("titleNoFormatting", "No Title"));
		aq.id(R.id.meta).text(jo.optString("publisher", ""));
		
		JSONObject image = jo.optJSONObject("image");
		String tb = null;
		if(image != null){
			tb = image.optString("tbUrl");
			aq.id(R.id.tb).visible().image(tb);
		}else{
			aq.id(R.id.tb).gone();
		}
		
		
		
		return view;
		
	}
};


}}}

== Configuration ==

More fine tuning can be done when an application starts. A good place to set the configuration is in the onCreate() method of the application.

{{{

public class MainApplication extends Application{

	
	@Override
    public void onCreate() {     
          
        //set the max number of concurrent network connections, default is 4
	AjaxCallback.setNetworkLimit(8);

	//set the max number of icons (image width <= 50) to be cached in memory, default is 20
	BitmapAjaxCallback.setIconCacheLimit(20);

	//set the max number of images (image width > 50) to be cached in memory, default is 20
	BitmapAjaxCallback.setCacheLimit(40);

	//set the max size of an image to be cached in memory, default is 1600 pixels (ie. 400x400)
	BitmapAjaxCallback.setPixelLimit(400 * 400);
        
	//set the max size of the memory cache, default is 1M pixels (4MB)
	BitmapAjaxCallback.setMaxPixelLimit(2000000);		        
        
        super.onCreate();
    }
	
	
}
}}}

== Maintenance==

AQuery provides few utility functions to help you control ajax and caching behavior.

=== Cancel ===

{{{
public void onDestroy(){
	
	//stop all async calls when current activity is exiting
	AjaxCallback.cancel();
	
}
}}}


=== Clean Up ===

If you use file cache for images, regularly clean the cache dir when the application exits.

====Simple====

{{{
protected void onDestroy(){
	
	super.onDestroy();
	
	//clean the file cache when root activity exit
	//the resulting total cache size will be less than 3M
	AQUtility.cleanCacheAsync(this);
	
}

}}}

====Advance====
{{{
protected void onDestroy(){
	
	super.onDestroy();
	
	//clean the file cache with advance option
	long triggerSize = 3000000; //starts cleaning when cache size is larger than 3M
	long targetSize = 2000000;	//remove the least recently used files until cache size is less than 2M
	AQUtility.cleanCacheAsync(this, triggerSize, targetSize);
	
	
}

}}}

=== Low Memory ===

Low memory happens when the device is overloaded with apps. When this happens, we want to remove all images from memory cache.

{{{
public class MainApplication extends Application{

    @Override
    public void onLowMemory(){	

	//clear all memory cached images when system is in low memory
	//note that you can configure the max image cache count, see CONFIGURATION
    	BitmapAjaxCallback.clearCache();
    }
	
}
}}}