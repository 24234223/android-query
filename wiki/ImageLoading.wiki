#Asynchronous Image Loading with AndroidQuery

== Code ==

Asynchronous image loading is easy with AQuery.

===Simple===
{{{
//load an image to an ImageView from network, cache image to file and memory

aq.id(R.id.image1).image("http://www.vikispot.com/z/images/vikispot/android-w.png");
}}}

===Cache Control===
{{{

//load an image from network, but only cache with file

//this image is huge, avoid memory caching
boolean memCache = false;
boolean fileCache = true;

aq.id(R.id.image1).image("http://www.vikispot.com/z/images/vikispot/android-w.png", memCache, fileCache);
}}}

===Down Sampling (handling huge images)===
{{{

//we are loading a huge image from the network, but we only need the image to be bigger than 200 pixels wide
//passing in the target width of 200 will down sample the image to conserve memory
//aquery will only down sample with power of 2 (2,4,8...) for good image quality and efficiency
//the resulting image width will be between 200 and 399 pixels

String imageUrl = "http://farm6.static.flickr.com/5035/5802797131_a729dac808_b.jpg";		
aq.id(R.id.image1).image(imageUrl, true, true, 200, 0);
}}}

===Fallback Image===

{{{

//if we are not able to load the image, use a default image (R.drawable.default_image)

String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";
aq.id(R.id.image1).image(imageUrl, true, true, 0, R.drawable.default_image);

//make image view "invisible" if image failed to load
imageUrl = "http://a.b.com/invalid.jpg";		
aq.id(R.id.image1).image(imageUrl, true, true, 0, AQuery.INVISIBLE);


//make image view "gone" if image failed to load
aq.id(R.id.image1).image(imageUrl, true, true, 0, AQuery.GONE);


}}}

===Custom Callback===

{{{
String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";

final int tint = 0x77AA0000;

aq.id(R.id.image1).image(imageUrl, true, true, 0, 0, new BitmapAjaxCallback(){

	@Override
	public void callback(String url, ImageView iv, Bitmap bm, AjaxStatus status){
				
		iv.setImageBitmap(bm);
		
		//do something to the bitmap
		iv.setColorFilter(tint, PorterDuff.Mode.SRC_ATOP);
		
	}
	
});

}}}

=== File (Async) ===
{{{

//load image from a file asynchronously with down sampling.
//down sampling is recommended when loading huge images from camera

File file = new File(path);        
aq.id(R.id.avatar).image(file, 300);

}}}


=== Duplicated URL ===
{{{

//AQuery detects duplicated image urls request and only fetches 1 image and apply them to all associated image views

String imageUrl = "http://www.vikispot.com/z/images/vikispot/android-w.png";
aq.id(R.id.image1).image(imageUrl);
aq.id(R.id.image2).image(imageUrl);

}}}

=== Access Cached Images ===

{{{
//returns the cached file by url, returns null if url is not cached
File file = aq.getCachedFile(url);
}}}

== Configuration ==

More fine tuning can be done when an application starts. A good place to set the configuration is in the onCreate() method of the application.

{{{

public class MainApplication extends Application{

	
	@Override
    public void onCreate() {     
          
        //set the max number of concurrent network connections, default is 4
	AjaxCallback.setNetworkLimit(8);

	//set the max number of icons (image width <= 50) to be cached in memory, default is 20
	BitmapAjaxCallback.setIconCacheLimit(20);

	//set the max number of images (image width > 50) to be cached in memory, default is 20
	BitmapAjaxCallback.setCacheLimit(40);

	//set the max size of an image to be cached in memory, default is 1600 pixels (ie. 400x400)
	BitmapAjaxCallback.setPixelLimit(400 * 400);
        
	//set the max size of the memory cache, default is 1M pixels (4MB)
	BitmapAjaxCallback.setMaxPixelLimit(2000000);		        
        
        super.onCreate();
    }
	
	
}
}}}

== Maintenance==

AQuery provides few utility functions to help you control ajax and caching behavior.

=== Cancel ===

{{{
public void onDestroy(){
	
	//stop all async calls when current activity is exiting
	AjaxCallback.cancel();
	
}
}}}


=== Clean Up ===

If you use file cache for images, regularly clean the cache dir when the application exits.

Simple:

{{{
protected void onDestroy(){
	
	super.onDestroy();
	
	//clean the file cache when root activity exit
	//the resulting total cache size will be less than 3M
	AQUtility.cleanCacheAsync(this);
	
}

}}}

Advance:
{{{
protected void onDestroy(){
	
	super.onDestroy();
	
	//clean the file cache with advance option
	long triggerSize = 3000000; //starts cleaning when cache size is larger than 3M
	long targetSize = 2000000;	//remove the least recently used files until cache size is less than 2M
	AQUtility.cleanCacheAsync(this, triggerSize, targetSize);
	
	
}

}}}

=== Low Memory ===

Low memory happens when the device is overloaded with apps. When this happens, we want to remove all images from memory cache.

{{{
public class MainApplication extends Application{

    @Override
    public void onLowMemory(){	

	//clear all memory cached images when system is in low memory
	//note that you can configure the max image cache count, see CONFIGURATION
    	BitmapAjaxCallback.clearCache();
    }
	
}
}}}